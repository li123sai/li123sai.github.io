---
title: Oracle数据迁移注意点
date: 2023-07-29 17:10:29
categories:
- 数据库
- Oracle
tags:
- 数据迁移
---

## 一、背景

​		随着时间的推进，系统原来的表会满足不了业务的变化，可能需要新增字段或者新建表来满足业务需求。这时候就可能涉及到数据迁移。

​		Oracle数据库中的数据量和迁移的数据量直接影响数据迁移。假设数据库中只有一百万数据，然后需要迁移十万数据，可能什么也不需要管，直接迁移就可以，但是亿级就不一样了，如果还什么也不管，迁移必然错误频出，失败收场。

## 二、迁移注意点

### （1）表空间

​			Oracle的表空间属于 Oracle 中的存储结构，是 Oracle 中信息存储的最大逻辑单元，其下还包含有段，区，数据块等逻辑数据类型。Oracle 数据库是由一个或多个表空间组成。它在物理上与磁盘上的数据文件相对应(一个表空间由一个或多个数据文件组成，但一个数据文件只能属于一个表空间，一个表空间的大小等于其中所有数据文件的大小之和，数据库的大小等于其中所有表空间的大小之和)从物理上说数据库的数据存放在数据文件中，而从逻辑上说是被存放在表空间中的。Oracle 的表空间虽然可以设置自增(AUTOEXTEND)但是这个没有太大意义，因为表空间的单个文件有最大限制(默认32G)，超过了最大限制依然不能增加大小。所以需要定时的查看表空间使用率，针对不足的空间增加数据文件。

​	

| 名字           | 描述                                                         |
| :------------- | ------------------------------------------------------------ |
| 永久表空间     | 存储数据库中需要永久化的存储对象，比如视图、存储过程、索引。如果创建用户时，不指定其永久表空间，则会使用默认的表空间。 |
| TEMP临时表空间 | 存储数据库的中间执行过程，如:保存 order by数据库排序，分组时产生的临时数据。操作完成后存储的内容会被自动释放。临时表空间是通用的，所有的用户都使用 TEMP 作为临时表空间。 |
| UNDO表空间     | 保存数据修改前的副本。存储事务所修改的旧址，即被修改之前的数据。当我们对一张表中的数据进行修改的同时会对修改之前的信息进行保存，为了对数据执行回滚、恢复、撤销的操作。 |



**如果迁移时没有注意表空间是否快满了或者SQL的性能不好，就可能报一些错误：**

**报错**

| 错误码    | 错误描述                                                     |
| --------- | ------------------------------------------------------------ |
| ORA-30036 | UNDO 空间不足，无法扩展以容纳需要生成的额外回滚数据。导致原因:<br/>1.长时间运行的事务:长时间运行而不提交或回滚的事务会消耗大量的 UNDO 空间例如:一次执行 6KW+的 Merge，更新过程中事务会挂起，如果 UNDO 空间不充足会直接报错。<br/>2.UNDO 表空间太小:如果空间太小，无法容纳正在生成的 UNDO 数据量，会出现报错。<br/>3、高撤销使用率生成大量撤销数据的应用程序(例如:数据仓库或 OLAP 应用程序会消耗大量 UNDO 空间。 |
| ORA-01652 | 无法通过 128 (在TEMP 表空间中) 扩展 TEMP 段的过程。导致原因:<br/>1.TEMP 表空间不足:oracle 总是尽量分配连续空间，一旦没有足够可分配空间或分配不连续就会报错。<br/>2.存储大规模排序结果:order by、group by、union、sort-merge joins(排序合并连接)MERGE JOIN CARTESIAN(卡尔积合并连接) 。<br/>3.管理索引:索引的创建、重建。 |



**慢查询**

| 连接方式             | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| SORT-MERGE JOINS     | 排序合并连接使用不太广泛，大多数情况使用nested loops 或者 hash joins 执行效率更高。但是由于hash joins 只能用于等值连接条件，所以在非等值条件连接以及非like、非情况下，如果连接列上已有排序，使用 sort-merge joins连接方式能获得较好的执行效率。                                                                                                                                    支持大部分连接条件:比如> 、<  、>= 、<= 、不支持like 和 <>  . |
| MERGE JOIN CARTESIAN | 当一个sql中两个表无关联条件，或者关联条件可以被忽略的时候就会发生笛卡尔积。 |



## 三、总结

### 操作注意事项

1. 确定待操作数据范围，总量，还需要统计待修改表的总量。
2. 根据总量选择合适的操作方法。（取数，更新，插入)
3. 检查数据操作的性能。(执行计划)
4. 测试，一定要在生产同量级的的测试环境测试。如果是大数据量操作需要记录 UNDO 空间、TEMP 空间、对应操作的表空间使用情况。(看生产现有表空间使用率是否满足)
5. 验证数据，操作总量和之前的统计的待操作总量是否一致，操作列的值抽样查看是否符合预期。(数据库的数据不会骗人，数据对不上，肯定有意料之外的数据)
6. 根据实际情况制定回滚计划。

### 部署注意点

1. 脚本执行的时间点，执行的次数，是否支持多次执行(应用版本部署前或后)(预发环境和生产环境)

   新功能上线，涉及新数据通过代码可以更新，而历史数据需要铺数;

   a 如果需要在预发验证 ，预发也要铺数，后面再部署生产时产生的差异数据，铺数的时候是否需要排除。

   b 只在生产环境执行，如果版本前执行，执行完成前到部署版本这段时间，会不会产生差异数据。

2. 铺数脚本执行过程中是否影响其他联机交易(不停机的情说)

   a大面积补数的时候会上锁，在补数完成前的这段时间，如果用户有更新操作会失败。
